__author__ = 'zachary'
import random
import numpy as np
import matplotlib.pyplot as plt
from DataSet import DataSet

"""
Takes two vectors as input.  The w vector or hypothesis vector and the misclassified point vector.
Updated the w vector by taking the vector sum of w + x to give an updated w vector.
This updated w vector is the return value.  This w results in the input vector now being correctly classified wrt hypothesis
and target function.
"""


def update(h, data_set, index):
    if data_set.bools[index]:
        d = 1
    else:
        d = -1
    temp = np.add(w, np.multiply(d, data_set.points[index]))
    return temp


"""
A method to run the PLA on the generated data set.  Hypothesis starts as the 3D Z vector.  All points misclassified
under this hypoth.  Picks a random misclassified point wrt training value and updates the hypothesis with update().
Runs until all points correctly classified under hypothesis.  Returns the hypothesis vector.
Params: Points of data set (array of 2D arrays), boolean array of value of each point wrt target function,
and vector for first hypothesis. Toggle automatically set to True.
Return: If toggle True: Number of time steps to converge
If toggle False: final hypothesis.
"""


def pla(number, w, toggle="time"):
    t_converge = 0
    data_set = DataSet(number)
    while (True):
        check = False
        for count, point in enumerate(points):
            classification = vector_classify(point, w)
            if bools[count] != classification:
                w = update(w, point, bools, count)
                check = True
                t_converge += 1
        if check != True:
            break
    if toggle == "time":
        return t_converge
    elif toggle == "vector":
        return w
    else:
        return t_converge, w


"""
Adds line generated by PLA to the graph to show g line compared to f. Must be called before plot_points.
Params: g vector from PLA
Return: None
"""


def graph_g(g):
    m, b = vector_to_standard(g)
    plt.plot([((-1 - b) / m), ((1 - b) / m)], [-1, 1], 'b')


"""
Method to determine the average number of time step needed for PLA to converge to a valid hypothesis.
Params:  Number of points in data set
Return:  The average number of time steps needed for PLA to converge to valid hypothesis
"""


def convergence_time(number):
    t_average = 0.0
    e_average = 0.0
    for i in range(1, 1000):
        m, b = target_function()
        vectors, bools = generate_set(number, m, b)
        w = np.array([0.0, 0.0, 0.0])
        temp, w = pla(vectors, bools, w, "both")
        t_average = (t_average * i + temp) / (i + 1)
        e_average = (e_average * i + error(np.array([m, - 1, b]), w)) / (i + 1)
    return t_average, e_average


"""
Function to take hypothesis vector and return slope and intercept
Params: Hypothesis vector
Return: m, b of hypothesis vector
"""


def vector_to_standard(w):
    m = (- 1 / w[1]) * w[0]
    b = (- 1 / w[1]) * w[2]
    return m, b


"""
Takes a given hypothesis and target function and calculated the error defined as the probability that any point in the
defined plane will be misclassified under the given hypothesis.
Params:  target function slope and intercept, g slope and intercept.
Return: Probability of miscalculation.
"""


def error(f, g):
    error = 0.0
    points = np.random.uniform(-1, 1, (10000, 2))
    for point in points:
        if vector_classify(point, f) != vector_classify(point, g):
            error += 1
    return error / 10000


# print(convergence_time(10))
m, b = target_function()
vectors, bools = generate_set(100, m, b)
w = [0.0, 0.0, 0.0]
g = pla(vectors, bools, w, "vector")
print(error(np.array([m, - 1, b]), g))
graph_g(g)
plot_points(vectors, bools, m, b)
